

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modules &mdash; utr_finder v2 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="utr_finder v2 documentation" href="index.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="Introduction"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">utr_finder v2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="modules">
<span id="id1"></span><h1>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h1>
<p>Documentation for the classes and methods of the modules of <strong>INSERT PROGRAM
NAME</strong></p>
<div class="section" id="utr-finder">
<h2>utr_finder<a class="headerlink" href="#utr-finder" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-utr_finder"></span><p>Read rna-seq read-files, a human genome annotation, a fasta file of the
entire human genome, and an inpute file UTR_SETTINGS. Based on this, write from
one to three output files, depending on the settings, that give information
about the usage of 3UTRs in the rna-seq reads.</p>
<p>The core of the program is a pipeline where rna-seq reads are extracted and
treated in several steps. The steps are</p>
<ol class="arabic">
<li><p class="first">Extract the reads from a gem-mapping</p>
<blockquote>
<div><p>If run with <strong>polyA = true</strong> in the settings file
1.1) If requested, also extract the polyA reads
1.2) Treat the polyA reads: trimming of poly(A) tail + remapping to the genome
1.3) Intersect the remapped polyA reads with the 3UTR
1.4) Cluster the polyA reads that map to the 3UTR (stochastic cleavage)</p>
</div></blockquote>
</li>
<li><p class="first">Get the RPKM of the 3UTRs: run intersectBed on the 3UTR bedfile and the readfile</p>
</li>
<li><p class="first">Get read coverage of the 3UTRs: run coverageBed -d on the 3UTRs and the reads</p>
</li>
<li><dl class="first docutils">
<dt>Go through the coverage file one line at a time;</dt>
<dd><p class="first last">4.1) Each line is one base; each 3UTR exon has from 200-X0000 lines
4.2) While on the same utr, keep adding coverage data
4.3) When a line with a different UTR is encountered, pause, and calculate
output for the previous 3UTR. If however the previous 3UTR was part of a
multi-exon.......... begin here.</p>
</dd>
</dl>
</li>
</ol>
<dl class="docutils">
<dt>Dependencies:</dt>
<dd><ul class="first last simple">
<li>pyFasta</li>
<li>bedGraphToBigWig</li>
<li>bedTools</li>
<li>numpy (can easily be removed &#8211; just mean and std used)</li>
<li>matplotlib (optional &#8211; for plotting)</li>
<li>python 2.6.4 or greater</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="utr_finder.Annotation">
<em class="property">class </em><tt class="descclassname">utr_finder.</tt><tt class="descname">Annotation</tt><big>(</big><em>annotation_path</em><big>)</big><a class="headerlink" href="#utr_finder.Annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience class. Refers to the files and data structures relevant to
the annotation that has been supplied.</p>
</dd></dl>

<dl class="class">
<dt id="utr_finder.FullLength">
<em class="property">class </em><tt class="descclassname">utr_finder.</tt><tt class="descname">FullLength</tt><big>(</big><em>utr_ID</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for writing the &#8216;length&#8217; file. Calculates the output based on
variables from a UTR instance. Also writes the header of the &#8216;length&#8217; output
file.</p>
<dl class="method">
<dt id="utr_finder.FullLength.calculate_output">
<tt class="descname">calculate_output</tt><big>(</big><em>pas_list</em>, <em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength.calculate_output" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Calculate output variables if <em>this_utr</em> is nonempty:</dt>
<dd><ol class="first arabic simple">
<li>Get cumulative coverage using the <em>epsilon</em> parameter</li>
</ol>
<p class="last">2) See if there is a PAS close to the estimated end, and if so,
return the distance to that PAS</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="utr_finder.FullLength.cumul_minus">
<tt class="descname">cumul_minus</tt><big>(</big><em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength.cumul_minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the position of cumulative coverage (e.g 0.98) relative to the
length of the annotated 3UTR. This is refered to as the <em>epsilon</em>
position. Calculate the coverage on both sides of this position.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.FullLength.cumul_plus">
<tt class="descname">cumul_plus</tt><big>(</big><em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength.cumul_plus" title="Permalink to this definition">¶</a></dt>
<dd><p>See cumul_minus</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.FullLength.get_pas">
<tt class="descname">get_pas</tt><big>(</big><em>pas_list</em>, <em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength.get_pas" title="Permalink to this definition">¶</a></dt>
<dd><p>Return any close-by PAS and the distance to that PAS.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.FullLength.header_dict">
<tt class="descname">header_dict</tt><big>(</big><em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength.header_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary that maps header-entries to the UTR or FullLength
instances that are being written to file. This ensures that each column
contains the data that corresponds to the colum header.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.FullLength.header_order">
<tt class="descname">header_order</tt><big>(</big><big>)</big><a class="headerlink" href="#utr_finder.FullLength.header_order" title="Permalink to this definition">¶</a></dt>
<dd><p>The order in which colums appear in the &#8216;length&#8217; output file.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.FullLength.write_header">
<tt class="descname">write_header</tt><big>(</big><em>outfile</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength.write_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the header of the &#8216;length&#8217; output file</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.FullLength.write_output">
<tt class="descname">write_output</tt><big>(</big><em>outobject</em>, <em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.FullLength.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out the output as determined in &#8216;header_order()&#8217;</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="utr_finder.PolyAReads">
<em class="property">class </em><tt class="descclassname">utr_finder.</tt><tt class="descname">PolyAReads</tt><big>(</big><em>utr_ID</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns object for writing to &#8216;polyA&#8217; file. Contains method for writing
header of &#8216;polyA&#8217; file.</p>
<dl class="method">
<dt id="utr_finder.PolyAReads.calculate_output">
<tt class="descname">calculate_output</tt><big>(</big><em>pas_list</em>, <em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.calculate_output" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Calculate the following output:</dt>
<dd><p class="first"># The relative position of the cluster to non-extended UTR beg
# Average coverage 50nt on both sides of the cluster
# The distance to an annotated polyA site, if distance is less than</p>
<blockquote>
<div>40 nt.</div></blockquote>
<p class="last"># The distance and type of PAS, if closer than 40 nt.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="utr_finder.PolyAReads.get_PAS">
<tt class="descname">get_PAS</tt><big>(</big><em>pas_list</em>, <em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.get_PAS" title="Permalink to this definition">¶</a></dt>
<dd><p>Go through the -40 from the polyA read average. Collect any PAS you
find.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.PolyAReads.header_dict">
<tt class="descname">header_dict</tt><big>(</big><em>this_utr</em>, <em>polA_nr</em>, <em>pAcoord</em>, <em>nr_supp_pA</em>, <em>covR</em>, <em>covL</em>, <em>annotpA_dist</em>, <em>nearbyPAS</em>, <em>PAS_dist</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.header_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>See the equivalent method for the &#8216;FullLength&#8217; class.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.PolyAReads.header_order">
<tt class="descname">header_order</tt><big>(</big><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.header_order" title="Permalink to this definition">¶</a></dt>
<dd><p>See the equivalent method for the &#8216;FullLength&#8217; class.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.PolyAReads.read_annotation_support">
<tt class="descname">read_annotation_support</tt><big>(</big><em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.read_annotation_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the polyA cluster has an annotated polyA site nearby.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.PolyAReads.select_PAS">
<tt class="descname">select_PAS</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.select_PAS" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the best PAS in the list</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.PolyAReads.write_header">
<tt class="descname">write_header</tt><big>(</big><em>outfile</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.write_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the header of the &#8216;polyA&#8217; output file</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.PolyAReads.write_output">
<tt class="descname">write_output</tt><big>(</big><em>outobject</em>, <em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.PolyAReads.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the output in the order determined in &#8216;header_order()&#8217;. For each
UTR, there might be several polyA clusters. Each cluster gets a line in
the output file.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="utr_finder.Settings">
<em class="property">class </em><tt class="descclassname">utr_finder.</tt><tt class="descname">Settings</tt><big>(</big><em>datasets</em>, <em>annotation_path</em>, <em>utrfile_provided</em>, <em>read_limit</em>, <em>max_cores</em>, <em>chr1</em>, <em>hgfasta_path</em>, <em>polyA</em>, <em>min_utrlen</em>, <em>extendby</em>, <em>cumul_tuning</em>, <em>bigwig</em>, <em>bigwig_datasets</em>, <em>bigwig_savedir</em>, <em>bigwig_url</em><big>)</big><a class="headerlink" href="#utr_finder.Settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience class.One instance is created from this class: it holds all the
settings parameters obtained from the UTR_SETTINGS file.</p>
<dl class="method">
<dt id="utr_finder.Settings.DEBUGGING">
<tt class="descname">DEBUGGING</tt><big>(</big><big>)</big><a class="headerlink" href="#utr_finder.Settings.DEBUGGING" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify settings for debugging ONLY!</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="utr_finder.UTR">
<em class="property">class </em><tt class="descclassname">utr_finder.</tt><tt class="descname">UTR</tt><big>(</big><em>chrm</em>, <em>beg</em>, <em>end</em>, <em>strand</em>, <em>val</em>, <em>utr_ID</em>, <em>rpkm</em>, <em>extendby</em>, <em>first_covr</em>, <em>sequence</em>, <em>polyA_reads</em>, <em>a_polyA_sites</em><big>)</big><a class="headerlink" href="#utr_finder.UTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for UTR-objects. Holds all the relevant information about a UTR-object
that has been calculated in the pipeline. Attributes are either
variables that are written to output files, or variables that assist in
calculating the output variables.</p>
<dl class="method">
<dt id="utr_finder.UTR.is_empty">
<tt class="descname">is_empty</tt><big>(</big><big>)</big><a class="headerlink" href="#utr_finder.UTR.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if non-extended coverage vector is empty, i.e, has no
read-coverage.</p>
</dd></dl>

<dl class="method">
<dt id="utr_finder.UTR.update_utr">
<tt class="descname">update_utr</tt><big>(</big><em>new_exon</em><big>)</big><a class="headerlink" href="#utr_finder.UTR.update_utr" title="Permalink to this definition">¶</a></dt>
<dd><p>For multi-exon 3UTRs. Updates the attributes of the UTR-object with the
next exon with the next exon. The first exon&#8217;s ID will be the one
written to file.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="utr_finder.calc_write_tuning">
<tt class="descclassname">utr_finder.</tt><tt class="descname">calc_write_tuning</tt><big>(</big><em>tuning_handle</em>, <em>length_output</em>, <em>this_utr</em><big>)</big><a class="headerlink" href="#utr_finder.calc_write_tuning" title="Permalink to this definition">¶</a></dt>
<dd><p>Write parameters for tuning them. Used to determine the epsilon value for
finding the cut-off where an UTR ends, and also for the before/after
coverage ration of the polyA clusters.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.cluster_loop">
<tt class="descclassname">utr_finder.</tt><tt class="descname">cluster_loop</tt><big>(</big><em>ends</em><big>)</big><a class="headerlink" href="#utr_finder.cluster_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster the polyA reads together. It is assumed that the list &#8216;ends&#8217; comes
in as sorted. Go through the list; the first site is a cluster; if the
second site is within 20nt, it also becomes a cluster, and the new cluster
site is the average of the two sites. If the next site were not withing 20
nt, then this previous site is kept as a cluster, and the new site is the
new cluster; and so on.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.cluster_polyAs">
<tt class="descclassname">utr_finder.</tt><tt class="descname">cluster_polyAs</tt><big>(</big><em>utr_polyAs</em>, <em>utrs</em><big>)</big><a class="headerlink" href="#utr_finder.cluster_polyAs" title="Permalink to this definition">¶</a></dt>
<dd><p>For each UTR, save the clustered poly(A)-reads from both strands. For
double-stranded reads, it is known that the poly(A) reads map to the
opposite side of the strand it came from. This information is helpful in
estimating the false positive rate.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.concat_bedfiles">
<tt class="descclassname">utr_finder.</tt><tt class="descname">concat_bedfiles</tt><big>(</big><em>dset_reads</em>, <em>out_path</em>, <em>polyA</em>, <em>polyA_path</em><big>)</big><a class="headerlink" href="#utr_finder.concat_bedfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Throw zcat on the bedfiles. With the -f option, it will concatenate both
compressed and noncompressed files.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.coverage_wrapper">
<tt class="descclassname">utr_finder.</tt><tt class="descname">coverage_wrapper</tt><big>(</big><em>dset_id</em>, <em>filtered_reads</em>, <em>utrfile_path</em>, <em>options</em><big>)</big><a class="headerlink" href="#utr_finder.coverage_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around coverageBed. Calcuates coverage of the reads over the
3UTR-regions, or whatever region was sent in to the program. If the region
is large, this takes a lot of time, and the resulting file is huge.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.frmt">
<tt class="descclassname">utr_finder.</tt><tt class="descname">frmt</tt><big>(</big><em>element</em><big>)</big><a class="headerlink" href="#utr_finder.frmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return floats as strings with four decimals.
Return ints as strings.
Return all other objects as they came in.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.get_a_polyA_sites_path">
<tt class="descclassname">utr_finder.</tt><tt class="descname">get_a_polyA_sites_path</tt><big>(</big><em>settings</em>, <em>beddir</em><big>)</big><a class="headerlink" href="#utr_finder.get_a_polyA_sites_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the <em>annotation_parser</em> module to obtain the locations of all annotated
utr-ends, in the program called &#8216;a_polyA_sites&#8217;.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.get_bed_reads">
<tt class="descclassname">utr_finder.</tt><tt class="descname">get_bed_reads</tt><big>(</big><em>dset_reads</em>, <em>dset_id</em>, <em>read_limit</em>, <em>tempdir</em>, <em>polyA</em><big>)</big><a class="headerlink" href="#utr_finder.get_bed_reads" title="Permalink to this definition">¶</a></dt>
<dd><p>Get reads from file. Determine file-type. If gem, extract from gem and
convert to bed. If .bed, concatenate the bedfiles and convert them to the
desired internal format.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.get_chr1_annotation">
<tt class="descclassname">utr_finder.</tt><tt class="descname">get_chr1_annotation</tt><big>(</big><em>settings</em>, <em>beddir</em><big>)</big><a class="headerlink" href="#utr_finder.get_chr1_annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>From the annotation, extract only entries for chromosome 1 and save to a
separate file. This file is needed for speed-runs of the pipeline, while
still giving relavant results.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.get_pas_list">
<tt class="descclassname">utr_finder.</tt><tt class="descname">get_pas_list</tt><big>(</big><big>)</big><a class="headerlink" href="#utr_finder.get_pas_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of PAS in order of appearance: when searching through it, you
will get the most common one first.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.get_polyA_utr">
<tt class="descclassname">utr_finder.</tt><tt class="descname">get_polyA_utr</tt><big>(</big><em>polyAbed</em>, <em>utrfile_path</em><big>)</big><a class="headerlink" href="#utr_finder.get_polyA_utr" title="Permalink to this definition">¶</a></dt>
<dd><p>Call intersectBed on the poly(A) reads and on the 3UTR file. Return
the surviving poly(A) reads in a dictionary, where each 3UTR (key) is points
to all its polyA sites.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.get_rpkm">
<tt class="descclassname">utr_finder.</tt><tt class="descname">get_rpkm</tt><big>(</big><em>reads</em>, <em>utrfile_path</em>, <em>total_reads</em>, <em>utrs</em>, <em>extendby</em>, <em>dset_id</em><big>)</big><a class="headerlink" href="#utr_finder.get_rpkm" title="Permalink to this definition">¶</a></dt>
<dd><p>Run coverageBed of reads on provided 3UTR and get RPKM. The RPKM is for the
un-extended 3UTR. You need: total number of reads, length of the UTR, and
the number of reads landing in this 3UTR. The rpkm measure has its problems
when it comes to comparison between samples, but it&#8217;s easy to calculate, and
it tells you about expression within one experiment.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.get_utr_path">
<tt class="descclassname">utr_finder.</tt><tt class="descname">get_utr_path</tt><big>(</big><em>settings</em>, <em>beddir</em><big>)</big><a class="headerlink" href="#utr_finder.get_utr_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get 3utr.bed-file path from annotation via annotation_parser module.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.join_multiexon_utr">
<tt class="descclassname">utr_finder.</tt><tt class="descname">join_multiexon_utr</tt><big>(</big><em>multi_exon_utr</em><big>)</big><a class="headerlink" href="#utr_finder.join_multiexon_utr" title="Permalink to this definition">¶</a></dt>
<dd><p>For multi-exon UTRs. When all exons in an UTR has been accounted for, start
with the first exon (determined by sorting), and call
&#8216;first_exon.update_utr(new_exon)&#8217; for all the new exons.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.main">
<tt class="descclassname">utr_finder.</tt><tt class="descname">main</tt><big>(</big><big>)</big><a class="headerlink" href="#utr_finder.main" title="Permalink to this definition">¶</a></dt>
<dd><p>The main method. This method is called if script is run as __main__.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.make_bigwigs">
<tt class="descclassname">utr_finder.</tt><tt class="descname">make_bigwigs</tt><big>(</big><em>settings</em>, <em>annotation</em>, <em>here</em><big>)</big><a class="headerlink" href="#utr_finder.make_bigwigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Make bigwig files of the polyA reads and the normal reads of the datasets
specified under [BIGWIG] in the UTR_SETTINGS file.</p>
<p>Turn the read coverage and polyA read .bedfiles into bigWig files.
These files can in turn be viewed on the UCSC genome browser.</p>
<p>Finally print out a USCS custom track line for usage with the bigWig file.</p>
<p>Steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Intersect with 3UTR (or whatever original bedfile was used)</li>
<li>Do .bed -&gt; .bedgraph</li>
<li>Do .bedgraph -&gt; bigWig</li>
<li>Print USCS line</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="utr_finder.make_directories">
<tt class="descclassname">utr_finder.</tt><tt class="descname">make_directories</tt><big>(</big><em>here</em>, <em>dirnames</em><big>)</big><a class="headerlink" href="#utr_finder.make_directories" title="Permalink to this definition">¶</a></dt>
<dd><p>For each name in dirnames, return a list of paths to newly created
directories in folder &#8216;here&#8217;. Don&#8217;t overwrite folders if they exist.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.map_reads">
<tt class="descclassname">utr_finder.</tt><tt class="descname">map_reads</tt><big>(</big><em>processed_reads</em>, <em>avrg_read_len</em><big>)</big><a class="headerlink" href="#utr_finder.map_reads" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the processed reads using gem-mapper. Use the average read length to
determine the number of mismatches for the mapper according to the following
scheme where X is the average read length:</p>
<blockquote>
<div><ul class="simple">
<li>if X &lt; 50, then 1 mismatch</li>
<li>if 50 &lt; X &lt; 100, then 2 mismatchs</li>
<li>if 100 &lt; X, then 3 mismatches</li>
</ul>
</div></blockquote>
<p>Regardless, only accept uniquely mapping reads.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.output_writer">
<tt class="descclassname">utr_finder.</tt><tt class="descname">output_writer</tt><big>(</big><em>dset_id</em>, <em>coverage</em>, <em>annotation</em>, <em>utr_seqs</em>, <em>rpkm</em>, <em>extendby</em>, <em>polyA_reads</em>, <em>settings</em><big>)</big><a class="headerlink" href="#utr_finder.output_writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Putting together all the info on the 3UTRs and writing to files. Write
one file mainly about the length of the 3UTR, and write another file about
the polyA sites found in the 3UTR.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.pipeline">
<tt class="descclassname">utr_finder.</tt><tt class="descname">pipeline</tt><big>(</big><em>dset_id</em>, <em>dset_reads</em>, <em>tempdir</em>, <em>output_dir</em>, <em>utr_seqs</em>, <em>settings</em>, <em>annotation</em><big>)</big><a class="headerlink" href="#utr_finder.pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Get reads, get polyA reads, cluster polyA reads, get coverage, combine it in
a 3UTr object, do calculations on the object attributes, write calculation
to output files ... this is where it all happens: the PIPEline.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.process_reads">
<tt class="descclassname">utr_finder.</tt><tt class="descname">process_reads</tt><big>(</big><em>pA_reads_path</em><big>)</big><a class="headerlink" href="#utr_finder.process_reads" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove reads that are too short or have a poor nucleotide composition.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.read_settings">
<tt class="descclassname">utr_finder.</tt><tt class="descname">read_settings</tt><big>(</big><em>settings_file</em><big>)</big><a class="headerlink" href="#utr_finder.read_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the settings and get all the settings parameters. These should be used
to create a &#8216;Settings&#8217; object.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.save_output">
<tt class="descclassname">utr_finder.</tt><tt class="descname">save_output</tt><big>(</big><em>final_dict</em>, <em>output_dir</em><big>)</big><a class="headerlink" href="#utr_finder.save_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy files in out_dict from the temp_files to the output folder. These are
the key output files that you don&#8217;t want to delete by accident.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.shape_provided_bed">
<tt class="descclassname">utr_finder.</tt><tt class="descname">shape_provided_bed</tt><big>(</big><em>utr_bed_path</em>, <em>settings</em><big>)</big><a class="headerlink" href="#utr_finder.shape_provided_bed" title="Permalink to this definition">¶</a></dt>
<dd><p>Go through provided bedfile and shape it to confirm with internal standards
in the program. Save in the bed-file directory.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.strip_tailA">
<tt class="descclassname">utr_finder.</tt><tt class="descname">strip_tailA</tt><big>(</big><em>seq</em>, <em>trail_A</em>, <em>non_A</em><big>)</big><a class="headerlink" href="#utr_finder.strip_tailA" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip the polyA tail of a read iteratively.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.strip_tailT">
<tt class="descclassname">utr_finder.</tt><tt class="descname">strip_tailT</tt><big>(</big><em>seq</em>, <em>lead_T</em>, <em>non_T</em><big>)</big><a class="headerlink" href="#utr_finder.strip_tailT" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip the polyT tail of a read iteratively.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.verify_access">
<tt class="descclassname">utr_finder.</tt><tt class="descname">verify_access</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#utr_finder.verify_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to access file &#8216;f&#8217;. If not successful, which means that the file either
doesn&#8217;t exist or you don&#8217;t have access to it, abort program.</p>
</dd></dl>

<dl class="function">
<dt id="utr_finder.zcat_wrapper">
<tt class="descclassname">utr_finder.</tt><tt class="descname">zcat_wrapper</tt><big>(</big><em>bed_reads</em>, <em>read_limit</em>, <em>out_path</em>, <em>polyA</em>, <em>polyA_path</em><big>)</big><a class="headerlink" href="#utr_finder.zcat_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around zcat. Called on gem-mapped reads. Write uniquely mapped
reads (up to 2 mismatches) to .bed file.</p>
<p>If polyA parameter was passed as True, write unmapped reads with leading
poly(T) or tailing poly(A) to .bed file. The read is written to the bed-file
as stripped of polyA or polyT stretch. Either 5 contiguous A/Ts or 6 A/Ts in
the last/first 7 nucleotides must be present for the read to be considered
as a putative poly(A) read.</p>
</dd></dl>

</div>
<div class="section" id="annotation-parser">
<h2>annotation_parser<a class="headerlink" href="#annotation-parser" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-annotation_parser"></span><p>Create bed files from annotation file. Specifically, create bed-files for all
annotated introns and exons in 5UTR, CDS, and 3UTR, as well as all annotated TTS
sites.</p>
<p>From the original annotation file, I must extract the following
aTTS
3UTR_exons
3UTR_terminal_exon
3UTR_introns
CDS_exons
CDS_introns
5UTR_exons
5UTR_introns</p>
<p>As well, the program has a function to get only 3UTR regions.</p>
<dl class="function">
<dt id="annotation_parser.bed_length">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">bed_length</tt><big>(</big><em>bed_file</em><big>)</big><a class="headerlink" href="#annotation_parser.bed_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the summed lengths of all entries in bed file</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.cluster_by_utrbeg_multi_exon">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">cluster_by_utrbeg_multi_exon</tt><big>(</big><em>multi_exon_transcripts</em>, <em>all_transcripts</em>, <em>genes</em>, <em>extendby</em>, <em>out_handle</em><big>)</big><a class="headerlink" href="#annotation_parser.cluster_by_utrbeg_multi_exon" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster multi exon transcripts by their utr-start sites.</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.extend_aTTS">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">extend_aTTS</tt><big>(</big><em>inpot</em>, <em>chr_sizes</em>, <em>extend_by</em><big>)</big><a class="headerlink" href="#annotation_parser.extend_aTTS" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the aTTS sites and replace original file with extended</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.feature_length">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">feature_length</tt><big>(</big><em>feature</em><big>)</big><a class="headerlink" href="#annotation_parser.feature_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of a (chr, beg, end, strnd) tuple</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.get_3utr_bed_all_exons">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">get_3utr_bed_all_exons</tt><big>(</big><em>settings</em>, <em>outfile_path</em><big>)</big><a class="headerlink" href="#annotation_parser.get_3utr_bed_all_exons" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the regions of all 3UTRs in the annotation. Cluster them by the
UTR-beg, and save for each cluster a &#8216;super-UTR&#8217; that contains all the
exons in that cluster. Save these regions to a bedfile in outfile_path.
Make sure that the last exon in each UTR is extended by the value set in
settings.extendby</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.get_a_polyA_sites_bed">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">get_a_polyA_sites_bed</tt><big>(</big><em>settings</em>, <em>outfile_path</em><big>)</big><a class="headerlink" href="#annotation_parser.get_a_polyA_sites_bed" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the polyA sites (end position of last exon) of annotated 3UTRs.
Save these positions to a bedfile in outfile_path. Cluster the polyA sites
and return the averages of the clusters.</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.get_intergenic">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">get_intergenic</tt><big>(</big><em>bed_dir</em>, <em>output</em>, <em>chr_sizes</em>, <em>chr1</em><big>)</big><a class="headerlink" href="#annotation_parser.get_intergenic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a .bed file for the whole genome. Then successively remove each
region from this file. Optionally divide into 3UTR proximal/distal...</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.get_seqs">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">get_seqs</tt><big>(</big><em>utr_dict</em>, <em>hgfasta</em><big>)</big><a class="headerlink" href="#annotation_parser.get_seqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the pyfasta module to get sequences quickly from an indexed version
of the human genome fasta file</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.make_transcripts">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">make_transcripts</tt><big>(</big><em>annotation</em><big>)</big><a class="headerlink" href="#annotation_parser.make_transcripts" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop through a (GENCODE) annotation file and get the exon fields.
Finally compose them into sets of transcripts. As well return a dictionary
of genes with the list of transcripts belonging to that gene.</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.merge_output">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">merge_output</tt><big>(</big><em>bed_dir</em>, <em>output</em><big>)</big><a class="headerlink" href="#annotation_parser.merge_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Run mergeBed on all the files in output and replace original</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.one_exon_cluster_write">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">one_exon_cluster_write</tt><big>(</big><em>one_exon_transcripts</em>, <em>all_transcripts</em>, <em>genes</em>, <em>extendby</em>, <em>out_handle</em><big>)</big><a class="headerlink" href="#annotation_parser.one_exon_cluster_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a set of Transcript objects whose genes should only have UTRs with
one exon. Clusters the UTRs of the transcripts together by their
UTR start sites. Removes or trims UTRs that overlap CDS exons for that
gene.</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.remove_intersects_and_extend">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">remove_intersects_and_extend</tt><big>(</big><em>unfiltered_path</em>, <em>outfile_path</em>, <em>all_transcripts</em>, <em>settings</em><big>)</big><a class="headerlink" href="#annotation_parser.remove_intersects_and_extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove UTR intersections with CDS exons. Remove UTR intersections with
UTRs from other genes. If sequences should be extended, do just that.</p>
</dd></dl>

<dl class="function">
<dt id="annotation_parser.remove_overlap">
<tt class="descclassname">annotation_parser.</tt><tt class="descname">remove_overlap</tt><big>(</big><em>bed_dir</em>, <em>output</em><big>)</big><a class="headerlink" href="#annotation_parser.remove_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that 3UTR_exons has no overlap with either aTTS_coding or
aTTS_processed. Make sure that cds_exons has no overlap with aTTS_processed.
Make sure that aTTS_processed does not overlap with aTTS_coding.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Modules</a><ul>
<li><a class="reference internal" href="#utr-finder">utr_finder</a></li>
<li><a class="reference internal" href="#annotation-parser">annotation_parser</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="introduction.html"
                        title="previous chapter">Introduction</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/modules.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="Introduction"
             >previous</a> |</li>
        <li><a href="index.html">utr_finder v2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Jorgen Skancke.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>